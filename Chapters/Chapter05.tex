%************************************************
\chapter{Evolutionary Algorithm}\label{ch:Representation}

In this chapter, level representation is discussed, as well as several genetic operators that will be later used to run the experiments. 

\section{Fitness function}

The most challenging part of the level generation process is to create stable structures. As obvious as it is the main feature of a stable level is that is not in motion. So it seems reasonable to evaluate that. 

$$fitness_{ind} = \frac{1}{|V|}\sum_{i=0}^{b}{V_i} + P_{broken}\cdot(b-|V|)$$

As mentioned in Chapter \ref{ch:gameApdaptation} the game output provides the average magnitude of velocity for each block. This vector is noted as $V$, with $|V|$ being the length of the vector. The number of blocks in an individual is $b$ and it can differ from the length of $V$ since broken blocks are not tracked. The number of broken blocks is $b-|V|$ and is multiplied by a penalization factor, since a level whose blocks break without user interaction would not be considered valid. This happens when a block free falls from a certain hight or collides with a falling object. $P_{broken}$ is set to $100$ since objects in a level do not usually reach that velocity, therefore it will separate not valid levels from potentially good ones.

Not all levels are evaluated using a simulation, since it is a costly process. Although we may know that a given level will perform poorly in the simulation, removing them from the population will cause a high loss of diversity. For that matter, before testing a level, there are some indicators that a level would not be suitable and can be skipped in the simulation. Those are its distance to the ground and the number of blocks that overlap.

If the lowest object is not close to the ground is very likely that all blocks will break in the impact. 

\section{Level representation}

Previous approaches to this problem (studied in Chapter \ref{ch:otherSolutions}) provide fairly constrained output. The constructive method presented creates pyramid-like structures and, even though there is a variety of levels, the method is highly specialized in this kind of levels. The search-based approach only produces tower structures adding some variety by having pre-built composed blocks. 

Since one of the objectives of this project is to explore the expressiveness and variability of \acs{SBPCG}, it seems reasonable to use a flexible representation. 

One of the early considered options, was the use of grammars. In this category we can find Grammatical Evolution\cite{lourencco2015sge} and Generative Grammatical Encodings\cite{hornby2001advantages}. The first one focuses on optimizing how a grammar is applied, which production rules expand and in which order. This means there is a grammar previous to the evolution process. In our specific case, designing a grammar that solves the problem is a deeply complex problem itself in addition to the optimization process. The generative grammatical encodings use a range of operations that are combined in the evolution process to form a grammar. Designing those operations is much easier which also allows greater variability in the output. 

Although those approaches are promising, the scope of this project and its time limitations made these options little feasible. Instead, we will try a less directed search than previous solutions while keeping a simple representation.
\subsection{Gene representation}
Individuals are composed by a list of blocks, each of them being a gene. Special pieces such as platforms, TNT boxes or pigs are not considered in this phase. The building blocks for the game have several attributes that characterize them: 

\begin{itemize}
	\item Type: there are eight regular blocks that can be placed in the level with distinct shapes or sizes. Represented as an integer between $0$ and 7.
	\item Position: coordinates $x$ and $y$ of the centre of the block in game units 
	\item Rotation: rotation of the block in degrees. Here are considered four different rotations, 0ยบ, 45ยบ, 90ยบ or 135ยบ represented as integers between $0$ and 3.
\end{itemize}

Using this representation a gene will be formed by two integers and two floating point numbers.
The position of the corners of the block is frequently required, so it is stored along with those attributes even though it can be calculated using the size, the position and rotation of the block. 

There are three types of materials in the game, which determine the durability of the block. However, this does not affect their stability, so it will remain constant for now as \textit{wood} material.


\subsection{Chromosome representation}

Individuals are a collection of genes, in the same way a level is a collection of building blocks. The number of blocks is variable and the order in which they are listed is not important. 

As previously stated, only promising individuals are tested in-game while those who do not,  are penalized. This penalty is stored, separately from the fitness value for the individual. The reason for this is that it may change over generations. The goal of the penalization is to maintain fitness value of not tested level above ---it is a minimization problem--- the in-game tested levels, so the starting point for fitness of such individuals is the worst in-game score.

One measure to evaluate is the number of overlapping blocks. The separating axis theorem\cite{ericson2004real} determines if two convex shapes intersect. It is commonly used in game development for detecting collisions. A level with blocks that occupy the same space is not likely to be stable, since the Unity Engine will solve the issue moving the blocks until there is no collision. Since Unity Engine is not open source and there is no documentation on how exactly those collisions are solved, we assume that an precise prediction of the positions of the blocks is not possible  and therefore the fitness value obtained could be inaccurate. 

Considering all of the above, the chromosome is composed by:
\begin{itemize}
	\item a list of genes
	\item a fitness value
	\item a penalty (set to $-1$ for in-game evaluated levels)
	\item number of overlapping blocks (calculated) 
\end{itemize}

%************************************************

%*****************************************
%*****************************************
%*****************************************
%*****************************************
%*****************************************
